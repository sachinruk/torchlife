# AUTOGENERATED! DO NOT EDIT! File to edit: 60_AFT_models.ipynb (unless otherwise specified).

__all__ = ['AFT']

# Cell
import torch
import torch.nn as nn
import torch.nn.functional as F

import matplotlib.pyplot as plt

# Cell
class AFT(nn.Module):
    """
    Accelerated Failure Time model
    parameters:
    - logpdf (function): function that outputs log probabilty of error between time and expected time
    - log1cdf (function): function that outputs log of 1 - cumulative probabilty of error between time and expected time
    - dim (optional): input dimensionality of variables
    - h (optional): number of hidden nodes
    """
    def __init__(self, logpdf, logcdf, dim:int=0, h:tuple=()):
        super().__init__()
        self.logpdf, self.logcdf = logpdf, logcdf
        self.β = nn.Parameter(-torch.rand(1))
        if dim > 0:
            nodes = (dim,) + h + (1,)
            self.layers = nn.ModuleList([nn.Linear(a,b, bias=False)
                                       for a,b in zip(nodes[:-1], nodes[1:])])

        self.eps = 1e-7

    def forward(self, t:torch.Tensor, x:torch.Tensor=None):
        # get the Kaplan Meier estimates
        μ = self.β
        if x:
            for layer in self.layers[:-1]:
                x = F.relu(layer(x))
            μ += self.layers[-1](x)
#         μ = torch.exp(μ)
#         breakpoint()
        ξ = torch.log(t + self.eps) - μ
        logpdf = self.logpdf(ξ)
        logcdf = self.logcdf(ξ)
        return logpdf, logcdf

    def survival_function(self, t:torch.Tensor, x:torch.Tensor=None):
        with torch.no_grad():
            # calculate cumulative hazard according to above
            _, Λ = self.forward(t, x)
            return torch.exp(Λ)

    def plot_survival_function(self, t:torch.Tensor, x:torch.Tensor=None):
        surv_fun = self.survival_function(t, x)

        # plot
        plt.figure(figsize=(12,5))
        plt.plot(t, surv_fun)
        plt.xlabel('Time')
        plt.ylabel('Survival Probability')
        plt.show()