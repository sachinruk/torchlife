# AUTOGENERATED! DO NOT EDIT! File to edit: 95_Losses.ipynb (unless otherwise specified).

__all__ = ['Loss', 'LossType', 'AFTLoss', 'aft_loss', 'HazardLoss', 'hazard_loss']

# Cell
from abc import ABC, abstractmethod
from typing import Callable, Tuple
import torch

# Cell
class Loss(ABC):
    @abstractmethod
    def __call__(event:torch.Tensor, *args):
        pass

# Cell
LossType = Callable[[torch.Tensor, torch.Tensor, torch.Tensor], torch.Tensor]

# Cell
class AFTLoss(Loss):
    @staticmethod
    def __call__(event:torch.Tensor, log_pdf: torch.Tensor, log_icdf: torch.Tensor) -> torch.Tensor:
        lik = event * log_pdf + (1 - event) * log_icdf
        return -lik.mean()

# Cell
def _aft_loss(
    log_pdf: torch.Tensor, log_cdf: torch.Tensor, e: torch.Tensor
) -> torch.Tensor:
    lik = e * log_pdf + (1 - e) * log_cdf
    return -lik.mean()


def aft_loss(log_prob, e):
    log_pdf, log_cdf = log_prob
    return _aft_loss(log_pdf, log_cdf, e)

# Cell
class HazardLoss(Loss):
    @staticmethod
    def __call__(event: torch.Tensor, logλ: torch.Tensor, Λ: torch.Tensor) -> torch.Tensor:
        log_lik = event * logλ - Λ
        return -log_lik.mean()

# Cell
def _hazard_loss(logλ: torch.Tensor, Λ: torch.Tensor, e: torch.Tensor) -> torch.Tensor:
    log_lik = e * logλ - Λ
    return -log_lik.mean()


def hazard_loss(
    hazard: Tuple[torch.Tensor, torch.Tensor], e: torch.Tensor
) -> torch.Tensor:
    """
    parameters:
    - hazard: log hazard and Cumulative hazard
    - e: torch.Tensor of 1 if death event occured and 0 otherwise
    """
    logλ, Λ = hazard
    return _hazard_loss(logλ, Λ, e)